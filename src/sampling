/* Class to represent a 3D Inverse Kinematics (IK) chain that can be solved for a given target using the FABRIK algorithm.
 * A FabrikChain3D consists primarily of a list of connected Bone3D objects, and a number of parameters which
 * keep track of settings related to how we go about solving the IK chain.*/
public class FabrikChain3D implements FabrikChain<FabrikBone3D, Vec3f, FabrikJoint3D, BaseboneConstraintType3D>, Serializable
{

	// ---------- Public Methods ------------

	

	/**
	 * Add a bone to the end of this IK chain given the direction unit vector and length of the new bone to add.
	 * <p>
	 * The bone added does not have any rotational constraints enforced, and will be drawn with a default colour
	 * of white at full opacity.
	 * <p>
	 * This method can only be used when the IK chain contains a basebone, as without it we do not
	 * have a start location for this bone (i.e. the end location of the previous bone).
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a {@link RuntimeException}
	 * is thrown.
	 * <p>
	 * If this method is provided with a direction unit vector of zero, or a bone length of zero then then an
	 * {@link IllegalArgumentException} is thrown.
	 * 
	 * @param	directionUV The initial direction of the new bone
	 * @param	length		The length of the new bone
	 */
	@Override
	public void addConsecutiveBone(Vec3f directionUV, float length) { addConsecutiveBone(directionUV, length, new Colour4f() ); }
	
	/**
	 * Add a consecutive bone to the end of this IK chain given the direction unit vector and length of the new bone to add.
	 * <p>
	 * The bone added does not have any rotational constraints enforced, and will be drawn with a default colour
	 * of white at full opacity.
	 * <p>
	 * This method can only be used when the IK chain contains a basebone, as without it we do not
	 * have a start location for this bone (i.e. the end location of the previous bone).
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a {@link RuntimeException}
	 * is thrown.
	 * <p>
	 * If this method is provided with a direction unit vector of zero, or a bone length of zero then then an
	 * {@link IllegalArgumentException} is thrown.
	 * 
	 * @param	directionUV The initial direction of the new bone
	 * @param	length		The length of the new bone
	 * @param	colour		The colour with which to draw the bone
	 */
	public void addConsecutiveBone(Vec3f directionUV, float length, Colour4f colour)
	{
		// Validate the direction unit vector - throws an IllegalArgumentException if it has a magnitude of zero
		Utils.validateDirectionUV(directionUV);
		
		// Validate the length of the bone - throws an IllegalArgumentException if it is not a positive value
		Utils.validateLength(length);
				
		// If we have at least one bone already in the chain...
		if (!my_chain.isEmpty())
		{				
			// Get the end location of the last bone, which will be used as the start location of the new bone
			Vec3f prevBoneEnd = my_chain.get(my_chain.size()-1).getEndLocation();
				
			// Add a bone to the end of this IK chain
			// Note: We use a normalised version of the bone direction
			addBone( new FabrikBone3D(prevBoneEnd, directionUV.normalised(), length, colour) );
		}
		else // Attempting to add a relative bone when there is no basebone for it to be relative to?
		{
			throw new RuntimeException("You cannot add the basebone as a consecutive bone as it does not provide a start location. Use the addBone() method instead.");
		}
	}
	
	/**
	 * Add a pre-created consecutive bone to the end of this IK chain.
	 * <p>
	 * This method can only be used when the IK chain contains a basebone, as without it we do not
	 * have a start location for this bone (i.e. the end location of the previous bone).
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a {@link RuntimeException}
	 * is thrown.
	 * <p>
	 * If this method is provided with a direction unit vector of zero, or a bone length of zero then then an
	 * {@link IllegalArgumentException} is thrown.
	 * 
	 * @param	bone		The bone to add to the end of the chain.
	 */
	public void addConsecutiveBone(FabrikBone3D bone)
	{
		// Validate the direction unit vector - throws an IllegalArgumentException if it has a magnitude of zero
		Vec3f dir = bone.getDirectionUV();
		Utils.validateDirectionUV(dir);
		
		// Validate the length of the bone - throws an IllegalArgumentException if it is not a positive value
		float len = bone.liveLength();
		Utils.validateLength(len);
			
		// If we have at least one bone already in the chain...
		if (!this.my_chain.isEmpty())
		{		
			// Get the end location of the last bone, which will be used as the start location of the new bone
			Vec3f prevBoneEnd = my_chain.get(this.my_chain.size()-1).getEndLocation();
						
			bone.setStartLocation(prevBoneEnd);
			bone.setEndLocation( prevBoneEnd.plus( dir.times(len)) );
					
			// Add a bone to the end of this IK chain
			addBone(bone);
		}
		else // Attempting to add a relative bone when there is no base bone for it to be relative to?
		{
			throw new RuntimeException("You cannot add the base bone to a chain using this method as it does not provide a start location.");
		}		
	}

	/**
	 * Add a consecutive hinge constrained bone to the end of this chain. The bone may rotate freely about the hinge axis.
	 * <p>
	 * The bone will be drawn with a default colour of white.
	 * <p>	 
	 * This method can only be used when the IK chain contains a basebone, as without it we do not
	 * have a start location for this bone (i.e. the end location of the previous bone).
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown.
	 * If this method is provided with a direction unit vector of zero, then an IllegalArgumentException is thrown.
	 * If the joint type requested is not JointType.LOCAL_HINGE or JointType.GLOBAL_HINGE then an IllegalArgumentException is thrown.
	 * If this method is provided with a hinge rotation axis unit vector of zero, then an IllegalArgumentException is thrown.
	 * 
	 * @param	directionUV			The initial direction of the new bone.
	 * @param	length				The length of the new bone.
	 * @param	jointType			The type of hinge joint to be used - either JointType.LOCAL or JointType.GLOBAL.
	 * @param	hingeRotationAxis	The axis about which the hinge joint freely rotates.
	 */
	public void addConsecutiveFreelyRotatingHingedBone(Vec3f directionUV, float length, JointType jointType, Vec3f hingeRotationAxis)
	{
		// Because we aren't constraining this bone to a reference axis within the hinge rotation axis we don't care about the hinge constraint
		// reference axis (7th param) so we'll just generate an axis perpendicular to the hinge rotation axis and use that.
		addConsecutiveHingedBone( directionUV, length, jointType, hingeRotationAxis, 180.0f, 180.0f, Vec3f.genPerpendicularVectorQuick(hingeRotationAxis), new Colour4f() );
	}
	
	/**
	 * Add a consecutive hinge constrained bone to the end of this chain. The bone may rotate freely about the hinge axis.
	 * <p>
	 * The bone will be drawn with a default colour of white.
	 * <p>	 
	 * This method can only be used when the IK chain contains a basebone, as without it we do not
	 * have a start location for this bone (i.e. the end location of the previous bone).
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown.
	 * If this method is provided with a direction unit vector of zero, then an IllegalArgumentException is thrown.
	 * If the joint type requested is not JointType.LOCAL_HINGE or JointType.GLOBAL_HINGE then an IllegalArgumentException is thrown.
	 * If this method is provided with a hinge rotation axis unit vector of zero, then an IllegalArgumentException is thrown.
	 * 
	 * @param	directionUV			The initial direction of the new bone.
	 * @param	length				The length of the new bone.
	 * @param	jointType			The type of hinge joint to be used - either JointType.LOCAL or JointType.GLOBAL.
	 * @param	hingeRotationAxis	The axis about which the hinge joint freely rotates.
	 * @param	colour				The colour to draw the bone.
	 */
	public void addConsecutiveFreelyRotatingHingedBone(Vec3f directionUV, float length, JointType jointType, Vec3f hingeRotationAxis, Colour4f colour)
	{
		// Because we aren't constraining this bone to a reference axis within the hinge rotation axis we don't care about the hinge constraint
		// reference axis (7th param) so we'll just generate an axis perpendicular to the hinge rotation axis and use that.
		addConsecutiveHingedBone(directionUV, length, jointType, hingeRotationAxis, 180.0f, 180.0f, Vec3f.genPerpendicularVectorQuick(hingeRotationAxis), colour);
	}
	
	/**
	 * Add a consecutive hinge constrained bone to the end of this IK chain.
	 * <p>
	 * The hinge type may be a global hinge where the rotation axis is specified in world-space, or
	 * a local hinge, where the rotation axis is relative to the previous bone in the chain.
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown. 
	 * If this method is provided with bone direction or hinge constraint axis of zero then an IllegalArgumentException is thrown.
	 * If the joint type requested is not LOCAL_HINGE or GLOBAL_HINGE then an IllegalArgumentException is thrown.
	 * 
	 * @param	directionUV			The initial direction of the new bone.
	 * @param	length				The length of the new bone.
	 * @param	jointType			The joint type of the new bone.	 
	 * @param	hingeRotationAxis	The axis about which the hinge rotates.
	 * @param	clockwiseDegs		The clockwise constraint angle in degrees.
	 * @param	anticlockwiseDegs	The anticlockwise constraint angle in degrees.
	 * @param	hingeReferenceAxis	The axis about which any clockwise/anticlockwise rotation constraints are enforced.
	 * @param	colour				The colour to draw the bone.
	 */
	public void addConsecutiveHingedBone(Vec3f directionUV,
			                                  float length,
			                           JointType jointType,
			                       Vec3f hingeRotationAxis,
			                           float clockwiseDegs,
			                       float anticlockwiseDegs,
			                      Vec3f hingeReferenceAxis,
			                                Colour4f colour)
	{	
		// Validate the direction and rotation axis unit vectors, and the length of the bone.
		Utils.validateDirectionUV(directionUV);
		Utils.validateDirectionUV(hingeRotationAxis);
		Utils.validateLength(length);
				
		// Cannot add a consectuive bone of any kind if the there is no basebone
		if (my_chain.isEmpty()) { 
		  throw new RuntimeException("You must add a basebone before adding a consectutive bone."); 
		}
		
		// Normalise the direction and hinge rotation axis 
		directionUV.normalise();
		hingeRotationAxis.normalise();
			
		// Get the end location of the last bone, which will be used as the start location of the new bone
		Vec3f prevBoneEnd = my_chain.get(my_chain.size()-1).getEndLocation();
			
		// Create a bone and set the draw colour...
		FabrikBone3D bone = new FabrikBone3D(prevBoneEnd, directionUV, length);
		bone.setColour(colour);
		
		// ...then create and set up a joint which we'll apply to that bone.
		FabrikJoint3D joint = new FabrikJoint3D();
		switch (jointType)
		{
			case GLOBAL_HINGE:
				joint.setAsGlobalHinge(hingeRotationAxis, clockwiseDegs, anticlockwiseDegs, hingeReferenceAxis);
				break;
			case LOCAL_HINGE:
				joint.setAsLocalHinge(hingeRotationAxis, clockwiseDegs, anticlockwiseDegs, hingeReferenceAxis);
				break;
			default:
				throw new IllegalArgumentException("Hinge joint types may be only JointType.GLOBAL_HINGE or JointType.LOCAL_HINGE.");
		}
		
		// Set the joint we just set up on the the new bone we just created
		bone.setJoint(joint);
		
		// Finally, add the bone to this chain
		addBone(bone);	
	}
	
	/**
	 * Add a consecutive hinge constrained bone to the end of this IK chain.
	 * <p>
	 * The hinge type may be a global hinge where the rotation axis is specified in world-space, or
	 * a local hinge, where the rotation axis is relative to the previous bone in the chain.
	 * <p>
	 * This method can only be used when the IK chain contains a basebone, as without it we do not
	 * have a start location for this bone (i.e. the end location of the previous bone).
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown. 
	 * If this method is provided with bone direction or hinge constraint axis of zero then an IllegalArgumentException is thrown.
	 * If the joint type requested is not LOCAL_HINGE or GLOBAL_HINGE then an IllegalArgumentException is thrown.
	 * 
	 * @param	directionUV						The initial direction of the new bone.
	 * @param	length							The length of the new bone.
	 * @param	jointType						The joint type of the new bone. 
	 * @param	hingeRotationAxis				The axis about which the hinge rotates.
	 * @param	clockwiseDegs					The clockwise constraint angle in degrees.
	 * @param	anticlockwiseDegs				The anticlockwise constraint angle in degrees.	 
	 * @param	hingeConstraintReferenceAxis	The reference axis about which any clockwise/anticlockwise rotation constraints are enforced.
	 */
	public void addConsecutiveHingedBone(Vec3f directionUV,
			                                       float length,
			                                       JointType jointType,
			                                       Vec3f hingeRotationAxis,
			                                       float clockwiseDegs,
			                                       float anticlockwiseDegs,
			                                       Vec3f hingeConstraintReferenceAxis)
	{	
		addConsecutiveHingedBone(directionUV, length, jointType, hingeRotationAxis, clockwiseDegs, anticlockwiseDegs, hingeConstraintReferenceAxis, new Colour4f() );
	}
	
	/**
	 * Add a consecutive rotor (i.e. ball joint) constrained bone to the end of this IK chain.
	 * <p>
	 * This method can only be used when the IK chain contains a basebone, as without it we do not
	 * have a start location for this bone (i.e. the end location of the previous bone).
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown. 
	 * If this method is provided with bone direction or hinge constraint axis of zero then an IllegalArgumentException is thrown.
	 * 
	 * @param	boneDirectionUV					The initial direction unit vector of the new bone.
	 * @param	boneLength						The length of the new bone.
	 * @param	constraintAngleDegs				The rotor constraint angle of the new bone.
	 * @param	colour							The colour to draw the bone.
	 */
	public void addConsecutiveRotorConstrainedBone(Vec3f boneDirectionUV, float boneLength, float constraintAngleDegs, Colour4f colour)
	{
		// Validate the bone direction and length and that we have a basebone
		Utils.validateDirectionUV(boneDirectionUV);
		Utils.validateLength(boneLength);
		if (my_chain.isEmpty()) { 
		  throw new RuntimeException("Add a basebone before attempting to add consectuive bones."); 
		}
				
		// Create the bone starting at the end of the previous bone, set its direction, constraint angle and colour
		// then add it to the chain. Note: The default joint type of a new FabrikBone3D is JointType.BALL.
		FabrikBone3D bone = new FabrikBone3D(my_chain.get(my_chain.size()-1).getEndLocation(), boneDirectionUV.normalise(), boneLength, colour);
		bone.setBallJointConstraintDegs(constraintAngleDegs);
		addBone(bone);
	}
	
	/**
	 * Add a consecutive rotor (i.e. ball joint) constrained bone to the end of this IK chain.
	 * <p>
	 * The bone will be drawn in white at full opacity by default. This method can only be used when the IK chain contains
	 * a basebone, as without it we do not have a start location for this bone (i.e. the end location of the previous bone).
	 * <p>
	 * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown. 
	 * If this method is provided with bone direction or hinge constraint axis of zero then an IllegalArgumentException is thrown.
	 * If the joint type requested is not LOCAL_HINGE or GLOBAL_HINGE then an IllegalArgumentException is thrown.
	 * 
	 * @param	boneDirectionUV		The initial direction unit vector of the new bone.
	 * @param	boneLength			The length of the new bone.
	 * @param	constraintAngleDegs	The rotor constraint angle for of the new bone.
	 */
	public void addConsecutiveRotorConstrainedBone(Vec3f boneDirectionUV, float boneLength, float constraintAngleDegs)
	{
		addConsecutiveRotorConstrainedBone( boneDirectionUV, boneLength, constraintAngleDegs, new Colour4f() );
	}	

	/**
	 * Set this chain to have a rotor basebone constraint.
	 * <p>
	 * Depending on whether the constraint type is GLOBAL_ROTOR or LOCAL_ROTOR the constraint will be applied
	 * about global space or about the local coordinate system of a bone in another chain that this chain is
	 * attached to.
	 * <p>
	 * The angle provided should be between the range of 0.0f (completely constrained) to 180.0f (completely free to
	 * rotate). Values outside of this range will be clamped to the relevant minimum or maximum.
	 * <p>
	 * If this chain does not contain a basebone then a RuntimeException is thrown.
	 * If the constraint axis is a zero vector or the rotor type is not GLOBAL_ROTOR or LOCAL_ROTOR then then an
	 * IllegalArgumentException is thrown.
	 * 
	 * @param	rotorType		The type of constraint to apply, this may be GLOBAL_ROTOR or LOCAL_ROTOR.
	 * @param	constraintAxis	The axis about which the rotor applies.
	 * @param	angleDegs		The angle about the constraint axis to limit movement in degrees. 
	 */
	public void setRotorBaseboneConstraint(BaseboneConstraintType3D rotorType, Vec3f constraintAxis, float angleDegs)
	{
		// Sanity checking
		if (my_chain.isEmpty())	{ 
		  throw new RuntimeException("Chain must contain a basebone before we can specify the basebone constraint type."); 
		}		
		if ( constraintAxis.length() <= 0.0f ) { 
		  throw new IllegalArgumentException("Constraint axis cannot be zero."); 
		}
		if (angleDegs < 0.0f ) { 
		  angleDegs = 0.0f; 
		}
		if (angleDegs > 180.0f) { 
		  angleDegs = 180.0f;
		}		
		if ( !(rotorType == BaseboneConstraintType3D.GLOBAL_ROTOR || rotorType == BaseboneConstraintType3D.LOCAL_ROTOR) )
		{
			throw new IllegalArgumentException("The only valid rotor types for this method are GLOBAL_ROTOR and LOCAL_ROTOR.");
		}
				
		// Set the constraint type, axis and angle
		mBaseboneConstraintType = rotorType;
		mBaseboneConstraintUV   = constraintAxis.normalised();
		mBaseboneRelativeConstraintUV.set(mBaseboneConstraintUV);
		getBone(0).getJoint().setAsBallJoint(angleDegs);
	}	
	
	/**
	 * Set this chain to have a hinged basebone constraint.
	 * <p>
	 * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
	 * If the hinge rotation or reference axes are zero vectors then an IllegalArgumentException is thrown.
	 * If the hinge reference axis does not lie in the plane of the hinge rotation axis (that is, they are not perpendicular)
	 * then an IllegalArgumentException is thrown.
	 * 
	 * @param hingeType				The type of constraint to apply, this may be GLOBAL_HINGE or LOCAL_HINGE.
	 * @param hingeRotationAxis		The axis about which the global hinge rotates.
	 * @param cwConstraintDegs		The clockwise constraint angle about the hinge reference axis in degrees.
	 * @param acwConstraintDegs		The clockwise constraint angle about the hinge reference axis in degrees.
	 * @param hingeReferenceAxis	The axis (perpendicular to the hinge rotation axis) about which the constraint angles apply.
	 */
	public void setHingeBaseboneConstraint(BaseboneConstraintType3D hingeType, Vec3f hingeRotationAxis, float cwConstraintDegs, float acwConstraintDegs, Vec3f hingeReferenceAxis)
	{
		// Sanity checking
		if (my_chain.isEmpty())	{ 
		  throw new RuntimeException("Chain must contain a basebone before we can specify the basebone constraint type."); 
		}		
		if ( hingeRotationAxis.length() <= 0.0f )  { 
		  throw new IllegalArgumentException("Hinge rotation axis cannot be zero.");
		}
		if ( hingeReferenceAxis.length() <= 0.0f ) { 
		  throw new IllegalArgumentException("Hinge reference axis cannot be zero.");	
		}
		if ( !( Vec3f.perpendicular(hingeRotationAxis, hingeReferenceAxis) ) ) {
			throw new IllegalArgumentException("The hinge reference axis must be in the plane of the hinge rotation axis, that is, they must be perpendicular.");
		}
		if ( !(hingeType == BaseboneConstraintType3D.GLOBAL_HINGE || hingeType == BaseboneConstraintType3D.LOCAL_HINGE) ) {	
			throw new IllegalArgumentException("The only valid hinge types for this method are GLOBAL_HINGE and LOCAL_HINGE.");
		}
		
		// Set the constraint type, axis and angle
		mBaseboneConstraintType = hingeType;
		mBaseboneConstraintUV.set( hingeRotationAxis.normalised() );
		
		FabrikJoint3D hinge = new FabrikJoint3D();
		
		if (hingeType == BaseboneConstraintType3D.GLOBAL_HINGE)
		{
			hinge.setHinge(JointType.GLOBAL_HINGE, hingeRotationAxis, cwConstraintDegs, acwConstraintDegs, hingeReferenceAxis);
		}
		else
		{
			hinge.setHinge(JointType.LOCAL_HINGE, hingeRotationAxis, cwConstraintDegs, acwConstraintDegs, hingeReferenceAxis);
		}
		getBone(0).setJoint(hinge);
	}
	
	/**
	 * Set this chain to have a freely rotating globally hinged basebone.
	 * <p>
	 * The clockwise and anticlockwise constraint angles are automatically set to 180 degrees and the hinge reference axis
	 * is generated to be any vector perpendicular to the hinge rotation axis.
	 * <p>
	 * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
	 * If the hinge rotation axis are zero vectors then an IllegalArgumentException is thrown.
	 * 
	 * @param hingeRotationAxis		The world-space axis about which the global hinge rotates.
	 */
	public void setFreelyRotatingGlobalHingedBasebone(Vec3f hingeRotationAxis)
	{
		setHingeBaseboneConstraint(BaseboneConstraintType3D.GLOBAL_HINGE, hingeRotationAxis, 180.0f, 180.0f, Vec3f.genPerpendicularVectorQuick(hingeRotationAxis) );
	}
	
	/**
	 * Set this chain to have a freely rotating globally hinged basebone.
	 * <p>
	 * The clockwise and anticlockwise constraint angles are automatically set to 180 degrees and the hinge reference axis
	 * is generated to be any vector perpendicular to the hinge rotation axis.
	 * <p>
	 * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
	 * If the hinge rotation axis are zero vectors then an IllegalArgumentException is thrown.
	 * 
	 * @param hingeRotationAxis		The world-space axis about which the global hinge rotates.
	 */
	public void setFreelyRotatingLocalHingedBasebone(Vec3f hingeRotationAxis)
	{
		setHingeBaseboneConstraint(BaseboneConstraintType3D.LOCAL_HINGE, hingeRotationAxis, 180.0f, 180.0f, Vec3f.genPerpendicularVectorQuick(hingeRotationAxis) );
	}
	
	/**
	 * Set this chain to have a locally hinged basebone.
	 * <p>
	 * The clockwise and anticlockwise constraint angles are automatically set to 180 degrees and the hinge reference axis
	 * is generated to be any vector perpendicular to the hinge rotation axis.
	 * <p>
	 * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
	 * If the hinge rotation axis are zero vectors then an IllegalArgumentException is thrown.
	 * 
	 * @param hingeRotationAxis		The local axis about which the hinge rotates.
	 * @param cwDegs				The clockwise constraint angle in degrees.
	 * @param acwDegs				The anticlockwise constraint angle in degrees.
	 * @param hingeReferenceAxis	The local reference axis about which the hinge is constrained.
	 * */
	public void setLocalHingedBasebone(Vec3f hingeRotationAxis, float cwDegs, float acwDegs, Vec3f hingeReferenceAxis)
	{
		setHingeBaseboneConstraint(BaseboneConstraintType3D.LOCAL_HINGE, hingeRotationAxis, cwDegs, acwDegs, hingeReferenceAxis);
	}
	
	/**
	 * Set this chain to have a globally hinged basebone.
	 * <p>
	 * The clockwise and anticlockwise constraint angles are automatically set to 180 degrees and the hinge reference axis
	 * is generated to be any vector perpendicular to the hinge rotation axis.
	 * <p>
	 * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
	 * If the hinge rotation axis are zero vectors then an IllegalArgumentException is thrown.
	 * 
	 * @param hingeRotationAxis		The global / world-space axis about which the hinge rotates.
	 * @param cwDegs				The clockwise constraint angle in degrees.
	 * @param acwDegs				The anticlockwise constraint angle in degrees.
	 * @param hingeReferenceAxis	The global / world-space reference axis about which the hinge is constrained.
	 * */
	public void setGlobalHingedBasebone(Vec3f hingeRotationAxis, float cwDegs, float acwDegs, Vec3f hingeReferenceAxis)
	{
		setHingeBaseboneConstraint(BaseboneConstraintType3D.GLOBAL_HINGE, hingeRotationAxis, cwDegs, acwDegs, hingeReferenceAxis);
	}
	
	// ---------- Private Methods ----------
	
	
	
	/**
	 * Update the embedded target for this chain.
	 * 
	 * The internal mEmbeddedTarget object is updated with the location of the provided parameter.
	 * If the chain is not in useEmbeddedTarget mode then a RuntimeException is thrown.
	 * Embedded target mode can be enabled by calling setEmbeddedTargetMode(true) on the chain.
	 * 
	 * @param newEmbeddedTarget	The location of the embedded target.
	 */
	@Override
	public void updateEmbeddedTarget(Vec3f newEmbeddedTarget)
	{
		// Using embedded target mode? Overwrite embedded target with provided location
		if (mUseEmbeddedTarget) { 
		  mEmbeddedTarget.set(newEmbeddedTarget); 
		}
		else { 
		  throw new RuntimeException("This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true)."); 
		}
	}
	
	/**
	 * Update the embedded target for this chain.
	 * 
	 * The internal mEmbeddedTarget object is updated with the location of the provided parameter.
	 * If the chain is not in useEmbeddedTarget mode then a RuntimeException is thrown.
	 * Embedded target mode can be enabled by calling setEmbeddedTargetMode(true) on the chain.
	 * 
	 * @param x	The x location of the embedded target.
	 * @param y	The y location of the embedded target.
	 * @param z	The z location of the embedded target.
	 */
	public void updateEmbeddedTarget(float x, float y, float z)
	{
		// Using embedded target mode? Overwrite embedded target with provided location
		if (mUseEmbeddedTarget) { 
		  mEmbeddedTarget.set( new Vec3f(x, y, z) ); 
		}
		else { 
		  throw new RuntimeException("This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true)."); 
		}
	}
	
	/**
	 * Clone and return the IK Chain of this FabrikChain3D, that is, the list of FabrikBone3D objects.
	 * 
	 * @return	A cloned List%lt;FabrikBone3D%gt;
	 */
	private List<FabrikBone3D> cloneIkChain()
	{
		// How many bones are in this chain?
		int numBones = my_chain.size();
		
		// Create a new Vector of FabrikBone3D objects of that size
		List<FabrikBone3D> clonedChain = new ArrayList<>(numBones);

		// For each bone in the chain being cloned...		
		for (FabrikBone3D aBone : this.my_chain)
		{
			// Use the copy constructor to create a new FabrikBone3D with the values set from the source FabrikBone3D.
			// and add it to the cloned chain.
			clonedChain.add( new FabrikBone3D( aBone ) );
		}
		
		return clonedChain;
	}



} // End of FabrikChain3D class
