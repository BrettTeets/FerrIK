/** 
	 * Set the relative basebone constraint UV - this direction should be relative to the coordinate space of the basebone.
	 *
	 * This function is deliberately made package-private as it should not be used by the end user - instead, the 
	 * FabrikStructure3D.solveForTarget() method will update this mBaseboneRelativeConstraintUV property FOR USE BY this
	 * chain as required.
	 * 
	 * The reason for this is that this chain on its own cannot calculate the relative constraint
	 * direction, because it relies on direction of the connected / 'host' bone in the chain that this chain is connected
	 * to - only we have no knowledge of that other chain! But, the FabrikStructure3D DOES have knowledge of that other
	 * chain, and is hence able to calculate and update this relative basebone constraint direction for us.
	 **/
	void setBaseboneRelativeConstraintUV(Vec3f constraintUV) { mBaseboneRelativeConstraintUV = constraintUV; }
	/** 
	 * Set the relative basebone reference constraint UV - this direction should be relative to the coordinate space of the basebone.
	 *
	 * This function is deliberately made package-private as it should not be used by the end user - instead, the 
	 * FabrikStructure3D.solveForTarget() method will update this mBaseboneRelativeConstraintUV property FOR USE BY this
	 * chain as required.
	 * 
	 * This property is required when we have a LOCAL_HINGE basebone constraint with reference axes - we must maintain the
	 * hinge's own rotation and reference axes, and then the FabrikStructure3D.solveForTarget() method updates the
	 * mBaseboneRelativeConstraintUV and mBaseboneRelativeReferenceConstraintUV as required.
	 **/
	void setBaseboneRelativeReferenceConstraintUV(Vec3f constraintUV) { mBaseboneRelativeReferenceConstraintUV = constraintUV; }

/**
	 * Method to solve this IK chain for the given target location.
	 * <p>
	 * The end result of running this method is that the IK chain configuration is updated.
	 * <p>
	 * To minimuse CPU usage, this method dynamically aborts if:
	 * - The solve distance (i.e. distance between the end effector and the target) is below the {@link solve_distance_threshold
},
	 * - A solution incrementally improves on the previous solution by less than the {@link mMinIterationChange}, or
	 * - The number of attempts to solve the IK chain exceeds the {@link mMaxIterationAttempts}. 
	 * 
	 * @param	newTarget	The location of the target for which we will solve this IK chain.
	 * @return	float		The resulting distance between the end effector and the new target location after solving the IK chain.
	 */
	@Override
	public float solveForTarget(Vec3f newTarget)
	{	
		// If we have both the same target and base location as the last run then do not solve
		if ( mLastTargetLocation.approximatelyEquals(newTarget, 0.001f) &&
			 mLastBaseLocation.approximatelyEquals(getBaseLocation(), 0.001f) )
		{
			return mCurrentSolveDistance;
		}
		
		/***
		 * NOTE: We must allow the best solution of THIS run to be used for a new target or base location - we cannot
		 * just use the last solution (even if it's better) - because that solution was for a different target / base
		 * location combination and NOT for the current setup.
		 */
						
		// Declare a list of bones to use to store our best solution
		List<FabrikBone3D> bestSolution = new ArrayList<>();
		
		// We start with a best solve distance that can be easily beaten
		float bestSolveDistance = Float.MAX_VALUE;
		
		// We'll also keep track of the solve distance from the last pass
		float lastPassSolveDistance = Float.MAX_VALUE;
		
		// Allow up to our iteration limit attempts at solving the chain
		float solveDistance;
		for (int loop = 0; loop < mMaxIterationAttempts; ++loop)
		{	
			// Solve the chain for this target
			solveDistance = solveIK(newTarget);
			
			// Did we solve it for distance? If so, update our best distance and best solution, and also
			// update our last pass solve distance. Note: We will ALWAYS beat our last solve distance on the first run. 
			if (solveDistance < bestSolveDistance)
			{	
				bestSolveDistance = solveDistance;
				bestSolution = this.cloneIkChain();
				
				// If we are happy that this solution meets our distance requirements then we can exit the loop now
				if (solveDistance <= solve_distance_threshold
        )
				{				
					break;
				}
			}
			else // Did not solve to our satisfaction? Okay...
			{
				// Did we grind to a halt? If so break out of loop to set the best distance and solution that we have
				if ( Math.abs(solveDistance - lastPassSolveDistance) < mMinIterationChange )
				{
					//System.out.println("Ground to halt on iteration: " + loop);
					break;
				}
			}
			
			// Update the last pass solve distance
			lastPassSolveDistance = solveDistance;
			
		} // End of loop
		
		// Update our solve distance and chain configuration to the best solution found
		mCurrentSolveDistance = bestSolveDistance;
		my_chain = bestSolution;
		
		// Update our base and target locations
		mLastBaseLocation.set( getBaseLocation() );
		mLastTargetLocation.set(newTarget);
		
		return mCurrentSolveDistance;
	}
    

