	/*** The core of a FabrikChain3D is a list of FabrikBone3D objects. It is this chain that we attempt to solve for a specified
	 * target location via the solveForTarget method(s).*/
	private List<FabrikBone3D> my_chain = new ArrayList<>();

	/** 
	 * The distance threshold we must meet in order to consider this FabrikChain3D to be successfully solved for distance.
	 * <p>
	 * When we solve a chain so that the distance between the end effector and target is less than or equal to the distance
	 * threshold, then we consider the chain to be solved and will dynamically abort any further attempts to solve the chain.
	 * <p>
	 * The default solve distance threshold is <strong>1.0f</strong>.
	 * <p>
	 * The minimum valid distance threshold is 0.0f, however a slightly higher value should be used to avoid forcing the IK
	 * chain solve process to run repeatedly when an <strong>acceptable</strong> (but not necessarily <em>perfect</em>)
	 * solution is found. Setting a very low solve distance threshold may result in significantly increased processor usage and
	 * hence increased processing time to solve a given IK chain.
	 * <p>	
	 * Although this property is the main criteria used to establish whether or not we have solved a given IK chain, it works
	 * in combination with the {@link #mMaxIterationAttempts} and {@link mMinIterationChange} fields to improve the
	 * performance of the algorithm in situations where we may not be able to solve a given IK chain. Such situations may arise
	 * when bones in the chain are highly constrained, or when the target is further away than the length of a chain which has
	 * a fixed base location.
	 * <p>
	 * See {@link #setSolveDistanceThreshold(float) }
	 * See {@link #mMaxIterationAttempts }
	 * See {@link #mMinIterationChange }
	 */
	private float solve_distance_threshold = 1.0f;

    /**
	 * Set the maximum number of attempts that will be made to solve this IK chain.
	 * <p>
	 * The FABRIK algorithm may require more than a single pass in order to solve
	 * a given IK chain for an acceptable distance threshold. If we reach this
	 * iteration limit then we stop attempting to solve the IK chain. Further details
	 * on this topic are provided in the {@link #mMaxIterationAttempts} documentation.
	 * <p>
	 * If a maxIterations value of less than 1 is provided then an IllegalArgumentException is
	 * thrown, as we must make at least a single attempt to solve an IK chain.
	 * 
	 * @param maxIterations  The maximum number of attempts that will be made to solve this IK chain.
	 */
	@Override
	public void setMaxIterationAttempts(int maxIterations)
	{
		// Ensure we have a valid maximum number of iteration attempts
		if (maxIterations < 1)
		{
			throw new IllegalArgumentException("The maximum number of attempts to solve this IK chain must be at least 1.");
		}
		
		// All good? Set the new maximum iteration attempts property
		mMaxIterationAttempts = maxIterations;
	}

    	/**
	 * Set the minimum iteration change before we dynamically abort any further attempts to solve this IK chain.
	 * <p>
	 * If the latest solution found has changed by less than this amount then we consider the progress being made
	 * to be not worth the computational effort and dynamically abort any further attempt to solve the chain for
	 * the current target to minimise CPU usage.
	 * <p>
	 * If a minIterationChange value of less than zero is specified then an IllegalArgumentException is
	 * thrown.
	 * 
	 * @param	minIterationChange  The minimum change in solve distance from one iteration to the next.
	 */
	@Override
	public void setMinIterationChange(float minIterationChange)
	{
		// Ensure we have a valid maximum number of iteration attempts
		if (minIterationChange < 0.0f)
		{
			throw new IllegalArgumentException("The minimum iteration change value must be more than or equal to zero.");
		}
		
		// All good? Set the new minimum iteration change distance
		mMinIterationChange = minIterationChange;
	}

    /**
	 * Set the distance threshold within which we consider the IK chain to be successfully solved.
	 * <p>
	 * If a solve distance value of less than zero is specified then an IllegalArgumentException is thrown.
	 * 
	 * @param  solveDistance  The distance between the end effector of this IK chain and target within which we will accept the solution.
	 */
	@Override
	public void setSolveDistanceThreshold(float solveDistance)
	{
		// Ensure we have a valid solve distance
		if (solveDistance < 0.0f)
		{
			throw new IllegalArgumentException("The solve distance threshold must be greater than or equal to zero.");
		}
		
		// All good? Set the new solve distance threshold
		solve_distance_threshold = solveDistance;
	}

    	/**
	 * maxIterationAttempts (int)	Specifies the maximum number of attempts that will be performed in order to solve the IK chain.
	 * If we have not solved the chain to within the solve distance threshold after this many attempts then we accept the best
	 * solution we have best on solve distance to target.
	 * <p>
	 * The default is 20 iteration attempts.
	 */
	private int mMaxIterationAttempts  = 20;

    
	

	/** 
	 * minIterationChange	(float)	Specifies the minimum distance improvement which must be made per solve attempt in order for us to believe it
	 * worthwhile to continue making attempts to solve the IK chain. If this iteration change is not exceeded then we abort any further solve
	 * attempts and accept the best solution we have based on solve distance to target.
	 * 
	 * The default is 0.01f.
	 */
	private float mMinIterationChange = 0.01f;

    /***
	 * Calculate the length of this IK chain by adding up the lengths of each bone.
	 * <p>
	 * The resulting chain length is stored in the my_chainLength property.
	 * <p>
	 * This method is called each time a bone is added to the chain. In addition, the
	 * length of each bone is recalculated during the process to ensure that our chain
	 * length is accurate. As the typical usage of a FabrikChain3D is to add a number
	 * of bones once (during setup) and then use them, this should not have any
	 * performance implication on the typical execution cycle of a FabrikChain3D object,
	 * as this method will not be called in any method which executes regularly. 
	 */
	@Override
	public void updateChainLength()
	{
		// We start adding up the length of the bones from an initial length of zero
		my_chainLength = 0.0f;

		// Loop over all the bones in the chain, adding the length of each bone to the my_chainLength property
		for (FabrikBone3D aBone : this.my_chain)
		{
			my_chainLength += aBone.length();
		}
	}

    
	/**
	 * chainLength	(float)	The chainLength is the combined length of all bones in this FabrikChain3D object.
	 * <p>
	 * When a FabrikBone3D is added or removed from the chain using the addBone, addConsecutiveBone or removeBone methods, then
	 * the chainLength is updated to reflect this.
	 * <p>
	 * See {@link #addBone(FabrikBone3D)}
	 * See {@link #addConsecutiveBone(FabrikBone3D)}
	 * See {@link #removeBone(int)}
	 */
	private float my_chainLength;

    /**
	 * Set the fixed basebone mode for this chain.
	 * <p>
	 * If the basebone is 'fixed' in place, then its start location cannot move. The bone is still allowed to
	 * rotate, with or without constraints.
	 * <p>
	 * Specifying a non-fixed base location while this chain is connected to another chain will result in a
	 * RuntimeException being thrown.
	 * <p>
	 * Fixing the basebone's start location in place and constraining to a global absolute direction are
	 * mutually exclusive. Disabling fixed base mode while the chain's constraint type is
	 * BaseboneConstraintType3D.GLOBAL_ABSOLUTE will result in a RuntimeException being thrown.	 * 
	 *  
	 * @param  value  Whether or not to fix the basebone start location in place.
	 */
	@Override
	public void setFixedBaseMode(boolean value)
	{	
		// Enforce that a chain connected to another chain stays in fixed base mode (i.e. it moves with the chain it's connected to instead of independently)
		if (!value && mConnectedChainNumber != -1)
		{
			throw new RuntimeException("This chain is connected to another chain so must remain in fixed base mode.");
		}
		
		// We cannot have a freely moving base location AND constrain the basebone to an absolute direction
		if (mBaseboneConstraintType == BaseboneConstraintType3D.GLOBAL_ROTOR && !value)
		{
			throw new RuntimeException("Cannot set a non-fixed base mode when the chain's constraint type is BaseboneConstraintType3D.GLOBAL_ABSOLUTE_ROTOR.");
		}
		
		// Above conditions met? Set the fixedBaseMode
		mFixedBaseMode = value;
	}

    	/** mFixedBaseMode	Whether this FabrikChain3D has a fixed (i.e. immovable) base location.
	 *
	 * By default, the location of the start joint of the first bone added to the IK chain is considered fixed. This
	 * 'anchors' the base of the chain in place. Optionally, a user may toggle this behaviour by calling
	 * {@link #setFixedBaseMode(boolean)} to enable or disable locking the basebone to a fixed starting location.
	 * 
	 * See {@link #setFixedBaseMode(boolean)}
	 */
	private boolean mFixedBaseMode = true;

    /** 
	 * mBaseLocation (Vec3f)	The location of the start joint of the first bone in the IK chain.
	 * <p>
	 * By default, FabrikChain3D objects are created with a fixed base location, that is the start joint
	 * of the first bone in the chain is not moved during the solving process. A user may still move this
	 * base location by calling setFixedBaseMode(boolean) and the FABRIK algorithm will then
	 * honour this new location as the 'fixed' base location.
	 * <p>
	 * The default is Vec3f(0.f, 0.0f).
	 * <p>
	 * See {@link #setFixedBaseMode(boolean)}
	 */	
	private Vec3f mFixedBaseLocation = new Vec3f();

    	/**
	 * Each chain has a BaseboneConstraintType3D - this may be either:
	 * - NONE,         // No constraint - basebone may rotate freely
	 * - GLOBAL_ROTOR, // World-space rotor (i.e. ball joint) constraint
	 * - LOCAL_ROTOR,  // Rotor constraint which is relative to the coordinate space of the connected bone
	 * - GLOBAL_HINGE, // World-space hinge constraint, or
	 * - LOCAL_HINGE   // Hinge constraint which is relative to the coordinate space of the connected bone
	 */ 
	private BaseboneConstraintType3D mBaseboneConstraintType = BaseboneConstraintType3D.NONE;

    /** mBaseboneConstraintUV	The direction around which we should constrain the basebone.
	 * <p>
	 * To ensure correct operation, the provided Vec3f is normalised inside the {@link #setBaseboneConstraintUV(Vec3f)} method. Passing a Vec3f
	 * with a magnitude of zero will result in the constraint not being set.
	 */
	private Vec3f mBaseboneConstraintUV = new Vec3f();
	
	/**
	 * mBaseboneRelativeConstraintUV	The basebone direction constraint in the coordinate space of the bone in another chain
	 * that this chain is connected to.
	 */
	private Vec3f mBaseboneRelativeConstraintUV = new Vec3f();
	
	/**
	 * mBaseboneRelativeReferenceConstraintUV	The basebone reference constraint in the coordinate space of the bone in another chain
	 * that this chain is connected to.
	 */
	private Vec3f mBaseboneRelativeReferenceConstraintUV = new Vec3f();
	
	/**
	 * mTargetlastLocation	The last target location for the end effector of this IK chain.
	 * <p>
	 * The target location can be updated via the {@link #solveForTarget(Vec3f)} or {@link #solveForTarget(float, float, float)} methods, which in turn
	 * will call the solveIK(Vec3f) method to attempt to solve the IK chain, resulting in an updated chain configuration.
	 * <p>
	 * The default is Vec3f(Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE)
	 */
	private Vec3f mLastTargetLocation = new Vec3f(Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE);
	
	/**
	 * The width in pixels of the line used to draw constraints for this chain.
	 * <p>
	 * The valid range is 1.0f to 32.0f inclusive.
	 * <p>
	 * The default is 2.0f pixels.
	 */
	private float mConstraintLineWidth = 2.0f;
	
	/** 
	 * The previous location of the start joint of the first bone added to the chain.
	 * <p>
	 * We keep track of the previous base location in order to use it to determine if the current base location and
	 * previous base location are the same, i.e. has the base location moved between the last run to this run? If
	 * the base location has moved, then we MUST solve the IK chain for this new base location - even if the target
	 * location has remained the same between runs.
	 * <p>
	 * The default is Vec3f(Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE).
	 * <p>
	 * See {@link #setFixedBaseMode(boolean)}
	 */	
	private Vec3f mLastBaseLocation = new Vec3f(Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE);

	/**
	 * mCurrentSolveDistance	The current distance between the end effector and the target location for this IK chain.
	 * <p>
	 * The current solve distance is updated when an attempt is made to solve the IK chain as triggered by a call to the
	 * {@link #solveForTarget(Vec3f)} or (@link #solveForTarget(float, float, float) methods.
	 */
	private float mCurrentSolveDistance = Float.MAX_VALUE;
	
	/**
	 * The zero-indexed number of the chain this chain is connected to in a FabrikStructure3D.
	 * <p>
	 * If the value is -1 then it's not connected to another bone or chain.
	 * 
	 * The default is -1.
	 */
	private int mConnectedChainNumber = -1;

    /**
	 * The zero-indexed number of the bone that this chain is connected to, if it's connected to another chain at all.
	 * <p>
	 * If the value is -1 then it's not connected to another bone or chain.
	 * 
	 * The default is -1.
	 */ 
	private int mConnectedBoneNumber  = -1;
	
	/**
	 * mEmbeddedTarget	An embedded target location which can be used to solve this chain.
	 * <p>
	 * Embedded target locations allow structures to be solved for multiple targets (one per chain in the structure)
	 * rather than all chains being solved for the same target. To use embedded targets, the mUseEmbeddedTargets flag
	 * must be true (which is not the default) - this flag can be set via a call to setEmbeddedTargetMode(true).
	 * 
	 * See (@link #setEmbeddedTargetMode(boolean) }
	 */
	private Vec3f mEmbeddedTarget = new Vec3f();
	
	/**
	 * mUseEmbeddedTarget	Whether or not to use the mEmbeddedTarget location when solving this chain.
	 * <p>
	 * This flag may be toggled by calling the setEmbeddedTargetMode(true) on the chain.
	 * <p>
	 * The default is false.
	 * <p>
	 * See {@link #setEmbeddedTargetMode(boolean) }
	 */
	private boolean mUseEmbeddedTarget = false;

    